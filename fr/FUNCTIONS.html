
<!DOCTYPE HTML>
<html lang="fr" >
    <head>
        <meta charset="UTF-8">
        <title>Fonctions · Clean Code TypeScript</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 4.0.0">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="OBJECTS-DATA.html" />
    
    
    <link rel="prev" href="VARIABLES.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Tapez pour rechercher" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="VARIABLES.html">
            
                <a href="VARIABLES.html">
            
                    
                    Variables
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3" data-path="FUNCTIONS.html">
            
                <a href="FUNCTIONS.html">
            
                    
                    Fonctions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="OBJECTS-DATA.html">
            
                <a href="OBJECTS-DATA.html">
            
                    
                    Objets et Structures de Données
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="CLASSES.html">
            
                <a href="CLASSES.html">
            
                    
                    Classes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="SOLID.html">
            
                <a href="SOLID.html">
            
                    
                    SOLID
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="TESTING.html">
            
                <a href="TESTING.html">
            
                    
                    Tests
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="CONCURRENCY.html">
            
                <a href="CONCURRENCY.html">
            
                    
                    Opérations Concurrentes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="ERROR-HANDLING.html">
            
                <a href="ERROR-HANDLING.html">
            
                    
                    Gestion des erreurs
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="FORMATTING.html">
            
                <a href="FORMATTING.html">
            
                    
                    Formatage du Code
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="COMMENTS.html">
            
                <a href="COMMENTS.html">
            
                    
                    Commentaires
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="TRANSLATIONS.html">
            
                <a href="TRANSLATIONS.html">
            
                    
                    Traductions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="LICENSE.html">
            
                <a href="LICENSE.html">
            
                    
                    Licence
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Publié avec HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Fonctions</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h2 id="fonctions">Fonctions</h2>
<h3 id="paramètres-dune-fonction-2-or-moins-idéalement">Paramètres d&apos;une fonction (2 or moins idéalement)</h3>
<p>Limiter le nombre de paramètres d&apos;une fonction est extrêmement important car cela
facilite le test de votre fonction. En avoir plus de trois conduit à une explosion
combinatoire où chaque argument doit être testé séparément dans des tonnes de cas
différents.</p>
<p>Avoir un ou deux paramètres par fonction est idéal, et trois devraient être évités
si possible. Rien de plus que cela devrait être consolidé. Assez souvent, si vous
avez plus de deux arguments, votre fonction essaie d&apos;en faire trop à la fois.
Dans les cas où ce n&apos;est pas le cas, la plupart du temps, un objet de niveau
supérieur suffit comme argument.</p>
<p>Pensez à utiliser des objets littéraux si vous avez besoin de beaucoup plus de paramètres.</p>
<p>Pour rendre évidentes les attributs que la fonction attend, vous pouvez utiliser
la syntaxe de <a href="https://basarat.gitbook.io/typescript/future-javascript/destructuring" target="_blank">déstructuration</a>.
Cela présente quelques avantages :</p>
<ol>
<li><p>Quand quelqu&apos;un regarde la signature d’une fonction, il est immédiatement clair
lesquels des attributs sont en train d’être utilisées.</p>
</li>
<li><p>Il peut être utilisé pour simuler des paramètres avec des noms.</p>
</li>
<li><p>La déstructuration clone également les valeurs primitives spécifiées de l&apos;objet
passé comme paramètre dans la fonction. Cela peut aider à prévenir les effets secondaires.
Remarque: les objets et les tableaux qui sont déstructurés à partir de l&apos;objet
argument ne sont PAS clonés.</p>
</li>
<li><p>TypeScript vous avertit des attributs non-utilisés, qui seraient impossibles
sans déstructuration.</p>
</li>
</ol>
<p><strong>Mal:</strong></p>
<pre><code class="lang-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMenu</span>(<span class="hljs-params">title: <span class="hljs-built_in">string</span>, body: <span class="hljs-built_in">string</span>, buttonText: <span class="hljs-built_in">string</span>, cancellable: <span class="hljs-built_in">boolean</span></span>) </span>{
  <span class="hljs-comment">// ...</span>
}

createMenu(<span class="hljs-string">&apos;Foo&apos;</span>, <span class="hljs-string">&apos;Bar&apos;</span>, <span class="hljs-string">&apos;Baz&apos;</span>, <span class="hljs-literal">true</span>);
</code></pre>
<p><strong>Bien:</strong></p>
<pre><code class="lang-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMenu</span>(<span class="hljs-params">options: { title: <span class="hljs-built_in">string</span>, body: <span class="hljs-built_in">string</span>, buttonText: <span class="hljs-built_in">string</span>, cancellable: <span class="hljs-built_in">boolean</span> }</span>) </span>{
  <span class="hljs-comment">// ...</span>
}

createMenu({
  <span class="hljs-attr">title</span>: <span class="hljs-string">&apos;Foo&apos;</span>,
  <span class="hljs-attr">body</span>: <span class="hljs-string">&apos;Bar&apos;</span>,
  <span class="hljs-attr">buttonText</span>: <span class="hljs-string">&apos;Baz&apos;</span>,
  <span class="hljs-attr">cancellable</span>: <span class="hljs-literal">true</span>
});
</code></pre>
<p>Vous pouvez encore améliorer la lisibilité en utilisant <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-aliases" target="_blank">type aliases (ou type d&apos;alias)</a>:</p>
<pre><code class="lang-ts">
<span class="hljs-keyword">type</span> MenuOptions = { <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">body</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">buttonText</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">cancellable</span>: <span class="hljs-built_in">boolean</span> };

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMenu</span>(<span class="hljs-params">options: MenuOptions</span>) </span>{
  <span class="hljs-comment">// ...</span>
}

createMenu({
  <span class="hljs-attr">title</span>: <span class="hljs-string">&apos;Foo&apos;</span>,
  <span class="hljs-attr">body</span>: <span class="hljs-string">&apos;Bar&apos;</span>,
  <span class="hljs-attr">buttonText</span>: <span class="hljs-string">&apos;Baz&apos;</span>,
  <span class="hljs-attr">cancellable</span>: <span class="hljs-literal">true</span>
});
</code></pre>
<h3 id="les-fonctions-devraient-faire-une-chose">Les fonctions devraient faire une chose</h3>
<p>C&apos;est de loin la règle la plus importante en ingénierie de logiciels. Lorsque
les fonctions font plus d&apos;une chose, elles sont plus difficiles à composer, à
tester et à raisonner. Lorsque vous arrivez à isoler une fonction afin d’exécuter
une seule tâche, elle peut être facilement refactorisée et votre code sera beaucoup
plus net. Si vous ne prenez en compte ce qui est dit dans ce guide, vous serez en
avance sur de nombreux développeurs.</p>
<p><strong>Mal:</strong></p>
<pre><code class="lang-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">emailClients</span>(<span class="hljs-params">clients: Client[]</span>) </span>{
  clients.forEach(<span class="hljs-function">(<span class="hljs-params">client</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> clientRecord = database.lookup(client);
    <span class="hljs-keyword">if</span> (clientRecord.isActive()) {
      email(client);
    }
  });
}
</code></pre>
<p><strong>Bien:</strong></p>
<pre><code class="lang-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">emailClients</span>(<span class="hljs-params">clients: Client[]</span>) </span>{
  clients.filter(isActiveClient).forEach(email);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isActiveClient</span>(<span class="hljs-params">client: Client</span>) </span>{
  <span class="hljs-keyword">const</span> clientRecord = database.lookup(client);
  <span class="hljs-keyword">return</span> clientRecord.isActive();
}
</code></pre>
<h3 id="les-noms-de-fonction-doivent-préciser-ce-quils-font">Les noms de fonction doivent préciser ce qu&apos;ils font</h3>
<p><strong>Mal:</strong></p>
<pre><code class="lang-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addToDate</span>(<span class="hljs-params">date: <span class="hljs-built_in">Date</span>, month: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">Date</span> </span>{
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();

<span class="hljs-comment">// It&apos;s hard to tell from the function name what is added</span>
addToDate(date, <span class="hljs-number">1</span>);
</code></pre>
<p><strong>Bien:</strong></p>
<pre><code class="lang-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addMonthToDate</span>(<span class="hljs-params">date: <span class="hljs-built_in">Date</span>, month: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">Date</span> </span>{
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
addMonthToDate(date, <span class="hljs-number">1</span>);
</code></pre>
<h3 id="les-fonctions-ne-doivent-avoir-quun-niveau-dabstraction">Les fonctions ne doivent avoir qu&apos;un niveau d&apos;abstraction</h3>
<p>Quand vous avez plus d&apos;un niveau d&apos;abstraction, votre fonction en fait généralement
trop. La division des fonctions conduit à une réutilisabilité et à des tests plus faciles.</p>
<p><strong>Mal:</strong></p>
<pre><code class="lang-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseCode</span>(<span class="hljs-params">code: <span class="hljs-built_in">string</span></span>) </span>{
  <span class="hljs-keyword">const</span> REGEXES = [ <span class="hljs-comment">/* ... */</span> ];
  <span class="hljs-keyword">const</span> statements = code.split(<span class="hljs-string">&apos; &apos;</span>);
  <span class="hljs-keyword">const</span> tokens = [];

  REGEXES.forEach(<span class="hljs-function">(<span class="hljs-params">regex</span>) =&gt;</span> {
    statements.forEach(<span class="hljs-function">(<span class="hljs-params">statement</span>) =&gt;</span> {
      <span class="hljs-comment">// ...</span>
    });
  });

  <span class="hljs-keyword">const</span> ast = [];
  tokens.forEach(<span class="hljs-function">(<span class="hljs-params">token</span>) =&gt;</span> {
    <span class="hljs-comment">// lex...</span>
  });

  ast.forEach(<span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> {
    <span class="hljs-comment">// parse...</span>
  });
}
</code></pre>
<p><strong>Bien:</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">const</span> REGEXES = [ <span class="hljs-comment">/* ... */</span> ];

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseCode</span>(<span class="hljs-params">code: <span class="hljs-built_in">string</span></span>) </span>{
  <span class="hljs-keyword">const</span> tokens = tokenize(code);
  <span class="hljs-keyword">const</span> syntaxTree = parse(tokens);

  syntaxTree.forEach(<span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> {
    <span class="hljs-comment">// parse...</span>
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tokenize</span>(<span class="hljs-params">code: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Token</span>[] </span>{
  <span class="hljs-keyword">const</span> statements = code.split(<span class="hljs-string">&apos; &apos;</span>);
  <span class="hljs-keyword">const</span> tokens: Token[] = [];

  REGEXES.forEach(<span class="hljs-function">(<span class="hljs-params">regex</span>) =&gt;</span> {
    statements.forEach(<span class="hljs-function">(<span class="hljs-params">statement</span>) =&gt;</span> {
      tokens.push( <span class="hljs-comment">/* ... */</span> );
    });
  });

  <span class="hljs-keyword">return</span> tokens;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span>(<span class="hljs-params">tokens: Token[]</span>): <span class="hljs-title">SyntaxTree</span> </span>{
  <span class="hljs-keyword">const</span> syntaxTree: SyntaxTree[] = [];
  tokens.forEach(<span class="hljs-function">(<span class="hljs-params">token</span>) =&gt;</span> {
    syntaxTree.push( <span class="hljs-comment">/* ... */</span> );
  });

  <span class="hljs-keyword">return</span> syntaxTree;
}
</code></pre>
<h3 id="eliminer-la-partie-dupliquée-du-code">Eliminer la partie dupliquée du code</h3>
<p>Faites de votre mieux pour éviter la duplication de certaines parties du votre code.
La duplication du code est mauvaise car cela signifie qu&apos;il y a plus d&apos;un endroit
pour modifier quelque chose si vous devez changer une logique.</p>
<p>Imaginez que vous dirigiez un restaurant et que vous gardiez une trace de votre
inventaire: toutes vos tomates, oignons, ail, épices, etc. Si vous avez plusieurs
listes sur lesquelles vous gardez cela, alors toutes doivent être mises à jour
lorsque vous servez un plat avec des tomates. Si vous n&apos;avez qu&apos;une seule liste,
il n&apos;y a qu&apos;un seul endroit à mettre à jour!</p>
<p>Souvent, vous avez du code en double parce que vous avez deux ou plusieurs choses
légèrement différentes, qui partagent beaucoup en commun, mais leurs différences
vous obligent à avoir deux ou plusieurs fonctions distinctes qui font à peu près
les mêmes choses. Supprimer le code en double signifie créer une abstraction qui
peut gérer cet ensemble de choses différentes avec une seule fonction/module/classe.</p>
<p>Avoir la correcte abstraction est essentiel, c&apos;est pourquoi vous devez suivre les
principes <a href="#solid">SOLID</a>. Les mauvaises abstractions peuvent être pires que le
code en double, alors faites attention! Cela dit, si vous pouvez faire une bonne
abstraction, faites-le! Ne vous répétez pas, sinon vous vous retrouverez à actualiser
plusieurs endroits chaque fois que vous voulez changer une chose.</p>
<p><strong>Mal:</strong></p>
<pre><code class="lang-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showDeveloperList</span>(<span class="hljs-params">developers: Developer[]</span>) </span>{
  developers.forEach(<span class="hljs-function">(<span class="hljs-params">developer</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> expectedSalary = developer.calculateExpectedSalary();
    <span class="hljs-keyword">const</span> experience = developer.getExperience();
    <span class="hljs-keyword">const</span> githubLink = developer.getGithubLink();

    <span class="hljs-keyword">const</span> data = {
      expectedSalary,
      experience,
      githubLink
    };

    render(data);
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showManagerList</span>(<span class="hljs-params">managers: Manager[]</span>) </span>{
  managers.forEach(<span class="hljs-function">(<span class="hljs-params">manager</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> expectedSalary = manager.calculateExpectedSalary();
    <span class="hljs-keyword">const</span> experience = manager.getExperience();
    <span class="hljs-keyword">const</span> portfolio = manager.getMBAProjects();

    <span class="hljs-keyword">const</span> data = {
      expectedSalary,
      experience,
      portfolio
    };

    render(data);
  });
}
</code></pre>
<p><strong>Bien:</strong></p>
<pre><code class="lang-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Developer</span> </span>{
  <span class="hljs-comment">// ...</span>
  <span class="hljs-function"><span class="hljs-title">getExtraDetails</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">githubLink</span>: <span class="hljs-built_in">this</span>.githubLink,
    }
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> </span>{
  <span class="hljs-comment">// ...</span>
  <span class="hljs-function"><span class="hljs-title">getExtraDetails</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">portfolio</span>: <span class="hljs-built_in">this</span>.portfolio,
    }
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showEmployeeList</span>(<span class="hljs-params">employee: Developer | Manager</span>) </span>{
  employee.forEach(<span class="hljs-function">(<span class="hljs-params">employee</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> expectedSalary = employee.calculateExpectedSalary();
    <span class="hljs-keyword">const</span> experience = employee.getExperience();
    <span class="hljs-keyword">const</span> extra = employee.getExtraDetails();

    <span class="hljs-keyword">const</span> data = {
      expectedSalary,
      experience,
      extra,
    };

    render(data);
  });
}
</code></pre>
<p>Vous devez être critique sur la duplication de code. Parfois, il y a un compromis
entre le code dupliqué et une complexité accrue en introduisant une abstraction
inutile. Lorsque deux implémentations de deux modules différents se ressemblent
mais vivent dans des domaines différents, la duplication peut être acceptable et
préférable à l&apos;extraction du code commun. Le code commun extrait dans ce cas
introduit une dépendance indirecte entre les deux modules.</p>
<h3 id="définir-les-objets-par-défaut-avec-objectassign-ou-déstructuration">Définir les objets par défaut avec “Object.assign” ou déstructuration</h3>
<p><strong>Mal:</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">type</span> MenuConfig = { title?: <span class="hljs-built_in">string</span>, body?: <span class="hljs-built_in">string</span>, buttonText?: <span class="hljs-built_in">string</span>, cancellable?: <span class="hljs-built_in">boolean</span> };

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMenu</span>(<span class="hljs-params">config: MenuConfig</span>) </span>{
  config.title = config.title || <span class="hljs-string">&apos;Foo&apos;</span>;
  config.body = config.body || <span class="hljs-string">&apos;Bar&apos;</span>;
  config.buttonText = config.buttonText || <span class="hljs-string">&apos;Baz&apos;</span>;
  config.cancellable = config.cancellable !== <span class="hljs-literal">undefined</span> ? config.cancellable : <span class="hljs-literal">true</span>;

  <span class="hljs-comment">// ...</span>
}

createMenu({ <span class="hljs-attr">body</span>: <span class="hljs-string">&apos;Bar&apos;</span> });
</code></pre>
<p><strong>Bien:</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">type</span> MenuConfig = { title?: <span class="hljs-built_in">string</span>, body?: <span class="hljs-built_in">string</span>, buttonText?: <span class="hljs-built_in">string</span>, cancellable?: <span class="hljs-built_in">boolean</span> };

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMenu</span>(<span class="hljs-params">config: MenuConfig</span>) </span>{
  <span class="hljs-keyword">const</span> menuConfig = <span class="hljs-built_in">Object</span>.assign({
    <span class="hljs-attr">title</span>: <span class="hljs-string">&apos;Foo&apos;</span>,
    <span class="hljs-attr">body</span>: <span class="hljs-string">&apos;Bar&apos;</span>,
    <span class="hljs-attr">buttonText</span>: <span class="hljs-string">&apos;Baz&apos;</span>,
    <span class="hljs-attr">cancellable</span>: <span class="hljs-literal">true</span>
  }, config);

  <span class="hljs-comment">// ...</span>
}

createMenu({ <span class="hljs-attr">body</span>: <span class="hljs-string">&apos;Bar&apos;</span> });
</code></pre>
<p>Également, vous pouvez utiliser la déstructuration avec des valeurs par défaut:</p>
<pre><code class="lang-ts"><span class="hljs-keyword">type</span> MenuConfig = { title?: <span class="hljs-built_in">string</span>, body?: <span class="hljs-built_in">string</span>, buttonText?: <span class="hljs-built_in">string</span>, cancellable?: <span class="hljs-built_in">boolean</span> };

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMenu</span>(<span class="hljs-params">{ title = <span class="hljs-string">&apos;Foo&apos;</span>, body = <span class="hljs-string">&apos;Bar&apos;</span>, buttonText = <span class="hljs-string">&apos;Baz&apos;</span>, cancellable = <span class="hljs-literal">true</span> }: MenuConfig</span>) </span>{
  <span class="hljs-comment">// ...</span>
}

createMenu({ <span class="hljs-attr">body</span>: <span class="hljs-string">&apos;Bar&apos;</span> });
</code></pre>
<p>Pour éviter tout effet secondaire et tout comportement inattendu en transmettant
explicitement la valeur <code>undefined</code> ou <code>null</code>, vous pouvez dire au compilateur de
TypeScript de ne pas l&apos;autoriser.
Consultez <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#--strictnullchecks" target="_blank"><code>--strictNullChecks</code></a> l&apos;option dans TypeScript.</p>
<h3 id="ne-pas-utiliser-pas-des-indicateurs-comme-paramètres-de-fonction">Ne pas utiliser pas des indicateurs comme paramètres de fonction</h3>
<p>Les indicateurs indiquent à votre utilisateur que cette fonction fait plus d&apos;une chose.
Les fonctions devraient faire une chose. Divisez vos fonctions si elles suivent des
chemins de code différents basés sur un booléen.</p>
<p><strong>Mal:</strong></p>
<pre><code class="lang-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFile</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, temp: <span class="hljs-built_in">boolean</span></span>) </span>{
  <span class="hljs-keyword">if</span> (temp) {
    fs.create(<span class="hljs-string">`./temp/<span class="hljs-subst">${name}</span>`</span>);
  } <span class="hljs-keyword">else</span> {
    fs.create(name);
  }
}
</code></pre>
<p><strong>Bien:</strong></p>
<pre><code class="lang-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createTempFile</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) </span>{
  createFile(<span class="hljs-string">`./temp/<span class="hljs-subst">${name}</span>`</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFile</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) </span>{
  fs.create(name);
}
</code></pre>
<h3 id="éviter-les-effets-secondaires-partie-1">Éviter les effets secondaires (partie 1)</h3>
<p>Une fonction produit un effet secondaire si elle fait autre chose que de prendre
une valeur et de renvoyer une ou plusieurs autres valeurs. Un effet secondaire
pourrait être d&apos;écrire dans un fichier, de modifier une variable globale ou de
transférer accidentellement tout votre argent à un étranger.</p>
<p>Maintenant, vous devez avoir des effets secondaires dans un programme à l&apos;occasion.
Comme dans l&apos;exemple précédent, vous devrez peut-être écrire dans un fichier. Ce
que vous voulez faire, c&apos;est de centraliser où vous faites cela. Ne pas avoir
plusieurs fonctions et classes qui écrivent dans un fichier particulier. Avoir
un service qui le fait. Seul et l&apos;unique.</p>
<p>Le point principal est d&apos;éviter les pièges courants comme le partage d&apos;état entre
des objets sans aucune structure, l&apos;utilisation de types de données mutables qui
peuvent être écrits par n&apos;importe quoi, et ne pas centraliser où se produisent
vos effets secondaires. Si vous pouvez le faire, vous serez plus heureux que la
grande majorité des autres programmeurs.</p>
<p><strong>Mal:</strong></p>
<pre><code class="lang-ts"><span class="hljs-comment">// Global variable referenced by following function.</span>
<span class="hljs-keyword">let</span> name = <span class="hljs-string">&apos;Robert C. Martin&apos;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toBase64</span>(<span class="hljs-params"></span>) </span>{
  name = btoa(name);
}

toBase64();
<span class="hljs-comment">// If we had another function that used this name, now it&apos;d be a Base64 value</span>

<span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// expected to print &apos;Robert C. Martin&apos; but instead &apos;Um9iZXJ0IEMuIE1hcnRpbg==&apos;</span>
</code></pre>
<p><strong>Bien:</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&apos;Robert C. Martin&apos;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toBase64</span>(<span class="hljs-params">text: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span> </span>{
  <span class="hljs-keyword">return</span> btoa(text);
}

<span class="hljs-keyword">const</span> encodedName = toBase64(name);
<span class="hljs-built_in">console</span>.log(name);
</code></pre>
<h3 id="éviter-les-effets-secondaires-partie-2">Éviter les effets secondaires (partie 2)</h3>
<p>En JavaScript, les primitives sont passées par valeur et les objets et tableaux
sont passés par référence. Dans le cas d&apos;objets et de tableaux, si votre fonction
modifie un tableau de panier d&apos;achat, par exemple, en ajoutant un article à acheter,
alors toute autre fonction qui utilise ce tableau <code>cart</code> sera affectée par cet
ajout. C&apos;est peut-être bien, mais ça peut aussi être mauvais. Imaginons une mauvaise situation:</p>
<p>L&apos;utilisateur clique sur le bouton “Achat”, qui appelle une fonction <code>purchase</code>
qui génère une demande réseau et envoie le tableau <code>cart</code> au serveur. En raison
d&apos;une mauvaise connexion réseau, la fonction d&apos;achat doit continuer à réessayer
la demande. Maintenant, que se passe-t-il si, dans l&apos;intervalle, l&apos;utilisateur
clique accidentellement sur le bouton <code>addItemToCart</code> sur un article qu&apos;il ne
souhaite pas avant le début de la demande réseau? Si cela se produit et que la
demande de réseau commence, alors cette fonction d&apos;achat enverra l&apos;article ajouté
accidentellement car il a une référence à un tableau de panier d&apos;achat que la
fonction <code>addItemToCart</code> a modifié en ajoutant un article indésirable.</p>
<p>Une excellente solution serait que <code>addItemToCart</code> clone toujours le<code>cart</code>, le
modifie et renvoie le clone. Cela garantit qu&apos;aucune autre fonction conservant
une référence du panier ne sera affectée par des modifications.</p>
<p>Deux avertissements à mentionner à cette approche:</p>
<ol>
<li><p>Il peut y avoir des cas où vous souhaitez réellement modifier l&apos;objet passée
comme paramètre, mais lorsque vous adoptez cette pratique de programmation, vous
constaterez que ces cas sont assez rares. La plupart des choses peuvent être
refactorisées pour n&apos;avoir aucun effet secondaire!
(voir <a href="https://en.wikipedia.org/wiki/Pure_function" target="_blank">fonction pure</a>)</p>
</li>
<li><p>Le clonage de gros objets peut être très coûteux en termes de performances.
Heureusement, ce n&apos;est pas un gros problème dans la pratique, car il existe d&apos;excellentes
bibliothèques qui permettent à ce type d&apos;approche de programmation d&apos;être rapide
et moins gourmande en mémoire que pour le clonage manuel d&apos;objets et de tableaux.</p>
</li>
</ol>
<p><strong>Mal:</strong></p>
<pre><code class="lang-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addItemToCart</span>(<span class="hljs-params">cart: CartItem[], item: Item</span>): <span class="hljs-title">void</span> </span>{
  cart.push({ item, <span class="hljs-attr">date</span>: <span class="hljs-built_in">Date</span>.now() });
};
</code></pre>
<p><strong>Bien:</strong></p>
<pre><code class="lang-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addItemToCart</span>(<span class="hljs-params">cart: CartItem[], item: Item</span>): <span class="hljs-title">CartItem</span>[] </span>{
  <span class="hljs-keyword">return</span> [...cart, { item, <span class="hljs-attr">date</span>: <span class="hljs-built_in">Date</span>.now() }];
};
</code></pre>
<h3 id="ne-pas-écrire-dans-les-fonctions-globales">Ne pas écrire dans les fonctions globales</h3>
<p>Polluer les fonctions globales est une mauvaise pratique en JavaScript car vous
pourriez entrer en conflit avec une autre bibliothèque et l&apos;utilisateur de votre
API ne serait pas plus sage jusqu&apos;à ce qu&apos;il obtienne une exception en production.
Réfléchissons à un exemple: et si vous vouliez étendre la méthode native Array
de JavaScript pour avoir une méthode <code>diff</code> qui pourrait montrer la différence
entre deux tableaux? Vous pouvez écrire votre nouvelle fonction dans le
<code>Array.prototype</code>, mais elle pourrait entrer en conflit avec une autre bibliothèque
qui a essayé de faire la même chose. Et si cette autre bibliothèque utilisait
simplement <code>diff</code> pour trouver la différence entre le premier et le dernier élément
d&apos;un tableau? C&apos;est pourquoi il serait beaucoup mieux d&apos;utiliser simplement des
classes et d&apos;étendre simplement le global <code>Array</code>.</p>
<p><strong>Mal:</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">declare</span> <span class="hljs-built_in">global</span> {
  <span class="hljs-keyword">interface</span> Array&lt;T&gt; {
    diff(other: T[]): <span class="hljs-built_in">Array</span>&lt;T&gt;;
  }
}

<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.prototype.diff) {
  <span class="hljs-built_in">Array</span>.prototype.diff = <span class="hljs-function"><span class="hljs-keyword">function</span> &lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">other: T[]</span>): <span class="hljs-title">T</span>[] </span>{
    <span class="hljs-keyword">const</span> hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(other);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.filter(<span class="hljs-function"><span class="hljs-params">elem</span> =&gt;</span> !hash.has(elem));
  };
}
</code></pre>
<p><strong>Bien:</strong></p>
<pre><code class="lang-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyArray</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Array</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
  diff(other: T[]): T[] {
    <span class="hljs-keyword">const</span> hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(other);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.filter(<span class="hljs-function"><span class="hljs-params">elem</span> =&gt;</span> !hash.has(elem));
  };
}
</code></pre>
<h3 id="privilégier-la-programmation-fonctionnelle-à-la-programmation-impérative">Privilégier la programmation fonctionnelle à la programmation impérative</h3>
<p>Privilégiez ce style de programmation quand vous le pouvez.</p>
<p><strong>Mal:</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">const</span> contributions = [
  {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&apos;Uncle Bobby&apos;</span>,
    <span class="hljs-attr">linesOfCode</span>: <span class="hljs-number">500</span>
  }, {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&apos;Suzie Q&apos;</span>,
    <span class="hljs-attr">linesOfCode</span>: <span class="hljs-number">1500</span>
  }, {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&apos;Jimmy Gosling&apos;</span>,
    <span class="hljs-attr">linesOfCode</span>: <span class="hljs-number">150</span>
  }, {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&apos;Gracie Hopper&apos;</span>,
    <span class="hljs-attr">linesOfCode</span>: <span class="hljs-number">1000</span>
  }
];

<span class="hljs-keyword">let</span> totalOutput = <span class="hljs-number">0</span>;

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; contributions.length; i++) {
  totalOutput += contributions[i].linesOfCode;
}
</code></pre>
<p><strong>Bien:</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">const</span> contributions = [
  {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&apos;Uncle Bobby&apos;</span>,
    <span class="hljs-attr">linesOfCode</span>: <span class="hljs-number">500</span>
  }, {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&apos;Suzie Q&apos;</span>,
    <span class="hljs-attr">linesOfCode</span>: <span class="hljs-number">1500</span>
  }, {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&apos;Jimmy Gosling&apos;</span>,
    <span class="hljs-attr">linesOfCode</span>: <span class="hljs-number">150</span>
  }, {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&apos;Gracie Hopper&apos;</span>,
    <span class="hljs-attr">linesOfCode</span>: <span class="hljs-number">1000</span>
  }
];

<span class="hljs-keyword">const</span> totalOutput = contributions
  .reduce(<span class="hljs-function">(<span class="hljs-params">totalLines, output</span>) =&gt;</span> totalLines + output.linesOfCode, <span class="hljs-number">0</span>);
</code></pre>
<h3 id="encapsuler-les-conditions">Encapsuler les conditions</h3>
<p><strong>Mal:</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">if</span> (subscription.isTrial || account.balance &gt; <span class="hljs-number">0</span>) {
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><strong>Bien:</strong></p>
<pre><code class="lang-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">canActivateService</span>(<span class="hljs-params">subscription: Subscription, account: Account</span>) </span>{
  <span class="hljs-keyword">return</span> subscription.isTrial || account.balance &gt; <span class="hljs-number">0</span>;
}

<span class="hljs-keyword">if</span> (canActivateService(subscription, account)) {
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<h3 id="éviter-les-conditions-négatives">Éviter les conditions négatives</h3>
<p><strong>Mal:</strong></p>
<pre><code class="lang-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEmailNotUsed</span>(<span class="hljs-params">email: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">boolean</span> </span>{
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-keyword">if</span> (isEmailNotUsed(email)) {
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><strong>Bien:</strong></p>
<pre><code class="lang-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEmailUsed</span>(<span class="hljs-params">email: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">boolean</span> </span>{
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-keyword">if</span> (!isEmailUsed(node)) {
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<h3 id="éviter-les-conditions">Éviter les conditions</h3>
<p>Cela semble être une tâche impossible. En entendant cela pour la première fois,
la plupart des gens disent: “Comment suis-je censé faire quoi que ce soit sans
une déclaration <code>if</code>?&quot; La réponse est que vous pouvez utiliser le polymorphisme
pour réaliser la même tâche dans de nombreux cas. La deuxième question est
généralement, &quot;c&apos;est bien, mais pourquoi voudrais-je faire ça?&quot; La réponse est
un concept de code propre précédent que nous avons appris: une fonction ne devrait
faire qu&apos;une seule chose. Lorsque vous avez des classes et des fonctions qui ont
des instructions <code>if</code>, vous dites à votre utilisateur que votre fonction fait
plus d&apos;une chose. N&apos;oubliez pas, faites juste une chose.</p>
<p><strong>Mal:</strong></p>
<pre><code class="lang-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Airplane</span> </span>{
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">// ...</span>

  <span class="hljs-function"><span class="hljs-title">getCruisingAltitude</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">this</span>.type) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&apos;777&apos;</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getMaxAltitude() - <span class="hljs-built_in">this</span>.getPassengerCount();
      <span class="hljs-keyword">case</span> <span class="hljs-string">&apos;Air Force One&apos;</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getMaxAltitude();
      <span class="hljs-keyword">case</span> <span class="hljs-string">&apos;Cessna&apos;</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getMaxAltitude() - <span class="hljs-built_in">this</span>.getFuelExpenditure();
      <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&apos;Unknown airplane type.&apos;</span>);
    }
  }

  <span class="hljs-keyword">private</span> getMaxAltitude(): <span class="hljs-built_in">number</span> {
    <span class="hljs-comment">// ...</span>
  }
}
</code></pre>
<p><strong>Bien:</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Airplane</span> </span>{
  <span class="hljs-keyword">protected</span> getMaxAltitude(): <span class="hljs-built_in">number</span> {
    <span class="hljs-comment">// shared logic with subclasses ...</span>
  }

  <span class="hljs-comment">// ...</span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Boeing777</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Airplane</span> </span>{
  <span class="hljs-comment">// ...</span>
  <span class="hljs-function"><span class="hljs-title">getCruisingAltitude</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getMaxAltitude() - <span class="hljs-built_in">this</span>.getPassengerCount();
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AirForceOne</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Airplane</span> </span>{
  <span class="hljs-comment">// ...</span>
  <span class="hljs-function"><span class="hljs-title">getCruisingAltitude</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getMaxAltitude();
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cessna</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Airplane</span> </span>{
  <span class="hljs-comment">// ...</span>
  <span class="hljs-function"><span class="hljs-title">getCruisingAltitude</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getMaxAltitude() - <span class="hljs-built_in">this</span>.getFuelExpenditure();
  }
}
</code></pre>
<h3 id="éviter-la-vérification-de-type-de-donnée">Éviter la vérification de type de donnée</h3>
<p>TypeScript est un superset syntaxique strict de JavaScript et ajoute une vérification
de type statique facultative au langage.
Préférez toujours spécifier des types de variables, des paramètres et des valeurs
de retour pour exploiter toute la puissance des fonctionnalités de TypeScript.
Cela facilite la refactorisation.</p>
<p><strong>Mal:</strong></p>
<pre><code class="lang-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">travelToTexas</span>(<span class="hljs-params">vehicle: Bicycle | Car</span>) </span>{
  <span class="hljs-keyword">if</span> (vehicle <span class="hljs-keyword">instanceof</span> Bicycle) {
    vehicle.pedal(currentLocation, <span class="hljs-keyword">new</span> Location(<span class="hljs-string">&apos;texas&apos;</span>));
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vehicle <span class="hljs-keyword">instanceof</span> Car) {
    vehicle.drive(currentLocation, <span class="hljs-keyword">new</span> Location(<span class="hljs-string">&apos;texas&apos;</span>));
  }
}
</code></pre>
<p><strong>Bien:</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">type</span> Vehicle = Bicycle | Car;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">travelToTexas</span>(<span class="hljs-params">vehicle: Vehicle</span>) </span>{
  vehicle.move(currentLocation, <span class="hljs-keyword">new</span> Location(<span class="hljs-string">&apos;texas&apos;</span>));
}
</code></pre>
<h3 id="ne-pas-trop-optimiser">Ne pas trop optimiser</h3>
<p>Les navigateurs modernes font beaucoup d&apos;optimisation sous le capot lors de l&apos;exécution.
Souvent, si vous optimisez, vous perdez simplement votre temps. Il existe de bonnes
<a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers" target="_blank">ressources</a>
pour voir où l&apos;optimisation fait défaut. Ciblez ceux en attendant, jusqu&apos;à ce
qu&apos;ils soient corrigés s&apos;ils le peuvent.</p>
<p><strong>Mal:</strong></p>
<pre><code class="lang-ts"><span class="hljs-comment">// On old browsers, each iteration with uncached `list.length` would be costly</span>
<span class="hljs-comment">// because of `list.length` recomputation. In modern browsers, this is optimized.</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = list.length; i &lt; len; i++) {
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><strong>Bien:</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) {
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<h3 id="éliminer-tout-code-qui-ne-sutilise-pas">Éliminer tout code qui ne s’utilise pas</h3>
<p>Le code qui ne s’utilise pas est tout aussi mauvais que le code en double. Il n&apos;y
a aucune raison de le conserver dans votre base de code. S&apos;il n&apos;est pas appelé,
débarrassez-vous-en! Il sera toujours sauvegardé en sécurité dans votre historique
de version si vous en avez toujours besoin.</p>
<p><strong>Mal:</strong></p>
<pre><code class="lang-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">oldRequestModule</span>(<span class="hljs-params">url: <span class="hljs-built_in">string</span></span>) </span>{
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requestModule</span>(<span class="hljs-params">url: <span class="hljs-built_in">string</span></span>) </span>{
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-keyword">const</span> req = requestModule;
inventoryTracker(<span class="hljs-string">&apos;apples&apos;</span>, req, <span class="hljs-string">&apos;www.inventory-awesome.io&apos;</span>);
</code></pre>
<p><strong>Bien:</strong></p>
<pre><code class="lang-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requestModule</span>(<span class="hljs-params">url: <span class="hljs-built_in">string</span></span>) </span>{
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-keyword">const</span> req = requestModule;
inventoryTracker(<span class="hljs-string">&apos;apples&apos;</span>, req, <span class="hljs-string">&apos;www.inventory-awesome.io&apos;</span>);
</code></pre>
<h3 id="utiliser-des-itérateurs-et-des-générateurs">Utiliser des itérateurs et des générateurs</h3>
<p>Utilisez des générateurs et des itérables lorsque vous travaillez avec des
collections de données utilisées comme un flux. Il y a quelques bonnes raisons:</p>
<ul>
<li>dissocie l&apos;appelé de la mise en œuvre du générateur dans le sens où l&apos;appelé
décide du nombre éléments à accéder</li>
<li>exécution paresseuse, les éléments sont diffusés à la demande</li>
<li>prise en charge intégrée pour l&apos;itération d&apos;éléments à l&apos;aide de la syntaxe <code>for-of</code></li>
<li>les itérables permettent d&apos;implémenter des modèles d&apos;itérateurs optimisés</li>
</ul>
<p><strong>Mal:</strong></p>
<pre><code class="lang-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fibonacci</span>(<span class="hljs-params">n: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span>[] </span>{
  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> [<span class="hljs-number">0</span>];
  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];

  <span class="hljs-keyword">const</span> items: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];
  <span class="hljs-keyword">while</span> (items.length &lt; n) {
    items.push(items[items.length - <span class="hljs-number">2</span>] + items[items.length - <span class="hljs-number">1</span>]);
  }

  <span class="hljs-keyword">return</span> items;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">n: <span class="hljs-built_in">number</span></span>) </span>{
  fibonacci(n).forEach(<span class="hljs-function"><span class="hljs-params">fib</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(fib));
}

<span class="hljs-comment">// Print first 10 Fibonacci numbers.</span>
print(<span class="hljs-number">10</span>);
</code></pre>
<p><strong>Bien:</strong></p>
<pre><code class="lang-ts"><span class="hljs-comment">// Generates an infinite stream of Fibonacci numbers.</span>
<span class="hljs-comment">// The generator doesn&apos;t keep the array of all numbers.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">fibonacci</span>(<span class="hljs-params"></span>): <span class="hljs-title">IterableIterator</span>&lt;<span class="hljs-title">number</span>&gt; </span>{
  <span class="hljs-keyword">let</span> [a, b] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];

  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">yield</span> a;
    [a, b] = [b, a + b];
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">n: <span class="hljs-built_in">number</span></span>) </span>{
  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> fib <span class="hljs-keyword">of</span> fibonacci()) {
    <span class="hljs-keyword">if</span> (i++ === n) <span class="hljs-keyword">break</span>;
    <span class="hljs-built_in">console</span>.log(fib);
  }
}

<span class="hljs-comment">// Print first 10 Fibonacci numbers.</span>
print(<span class="hljs-number">10</span>);
</code></pre>
<p>Il existe des bibliothèques qui permettent de travailler avec les itérables de
la même manière qu&apos;avec les tableaux natifs, en des méthodes de chaînage comme
<code>map</code>, <code>slice</code>, <code>forEach</code> etc. Voir <a href="https://www.npmjs.com/package/itiriri" target="_blank">itiriri</a>
pour un exemple de manipulation avancée avec les itérables
(ou <a href="https://www.npmjs.com/package/itiriri-async" target="_blank">itiriri-async</a> pour la manipulation
des itérables asynchrones).</p>
<pre><code class="lang-ts"><span class="hljs-keyword">import</span> itiriri <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;itiriri&apos;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">fibonacci</span>(<span class="hljs-params"></span>): <span class="hljs-title">IterableIterator</span>&lt;<span class="hljs-title">number</span>&gt; </span>{
  <span class="hljs-keyword">let</span> [a, b] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];

  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">yield</span> a;
    [a, b] = [b, a + b];
  }
}

itiriri(fibonacci())
  .take(<span class="hljs-number">10</span>)
  .forEach(<span class="hljs-function"><span class="hljs-params">fib</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(fib));
</code></pre>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="VARIABLES.html" class="navigation navigation-prev " aria-label="Previous page: Variables">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="OBJECTS-DATA.html" class="navigation navigation-next " aria-label="Next page: Objets et Structures de Données">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Fonctions","level":"1.3","depth":1,"next":{"title":"Objets et Structures de Données","level":"1.4","depth":1,"path":"OBJECTS-DATA.md","ref":"./OBJECTS-DATA.md","articles":[]},"previous":{"title":"Variables","level":"1.2","depth":1,"path":"VARIABLES.md","ref":"./VARIABLES.md","articles":[]},"dir":"ltr"},"config":{"plugins":[],"root":"./docs","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"Clean Code TypeScript","language":"fr","gitbook":"*"},"file":{"path":"FUNCTIONS.md","mtime":"2022-10-28T19:57:44.202Z","type":"markdown"},"gitbook":{"version":"4.0.0","time":"2022-10-28T19:57:59.682Z"},"basePath":".","book":{"language":"fr"}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

